"use strict";
/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.16.5.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSg721BaseOwnerOfQuery = exports.useSg721BaseApprovalQuery = exports.useSg721BaseApprovalsQuery = exports.useSg721BaseAllOperatorsQuery = exports.useSg721BaseNumTokensQuery = exports.useSg721BaseContractInfoQuery = exports.useSg721BaseNftInfoQuery = exports.useSg721BaseAllNftInfoQuery = exports.useSg721BaseTokensQuery = exports.useSg721BaseAllTokensQuery = exports.useSg721BaseMinterQuery = exports.useSg721BaseCollectionInfoQuery = exports.sg721BaseQueryKeys = void 0;
const react_query_1 = require("@tanstack/react-query");
exports.sg721BaseQueryKeys = {
    contract: [{
            contract: "sg721Base"
        }],
    address: (contractAddress) => [Object.assign(Object.assign({}, exports.sg721BaseQueryKeys.contract[0]), { address: contractAddress })],
    ownerOf: (contractAddress, args) => [Object.assign(Object.assign({}, exports.sg721BaseQueryKeys.address(contractAddress)[0]), { method: "owner_of", args })],
    approval: (contractAddress, args) => [Object.assign(Object.assign({}, exports.sg721BaseQueryKeys.address(contractAddress)[0]), { method: "approval", args })],
    approvals: (contractAddress, args) => [Object.assign(Object.assign({}, exports.sg721BaseQueryKeys.address(contractAddress)[0]), { method: "approvals", args })],
    allOperators: (contractAddress, args) => [Object.assign(Object.assign({}, exports.sg721BaseQueryKeys.address(contractAddress)[0]), { method: "all_operators", args })],
    numTokens: (contractAddress, args) => [Object.assign(Object.assign({}, exports.sg721BaseQueryKeys.address(contractAddress)[0]), { method: "num_tokens", args })],
    contractInfo: (contractAddress, args) => [Object.assign(Object.assign({}, exports.sg721BaseQueryKeys.address(contractAddress)[0]), { method: "contract_info", args })],
    nftInfo: (contractAddress, args) => [Object.assign(Object.assign({}, exports.sg721BaseQueryKeys.address(contractAddress)[0]), { method: "nft_info", args })],
    allNftInfo: (contractAddress, args) => [Object.assign(Object.assign({}, exports.sg721BaseQueryKeys.address(contractAddress)[0]), { method: "all_nft_info", args })],
    tokens: (contractAddress, args) => [Object.assign(Object.assign({}, exports.sg721BaseQueryKeys.address(contractAddress)[0]), { method: "tokens", args })],
    allTokens: (contractAddress, args) => [Object.assign(Object.assign({}, exports.sg721BaseQueryKeys.address(contractAddress)[0]), { method: "all_tokens", args })],
    minter: (contractAddress, args) => [Object.assign(Object.assign({}, exports.sg721BaseQueryKeys.address(contractAddress)[0]), { method: "minter", args })],
    collectionInfo: (contractAddress, args) => [Object.assign(Object.assign({}, exports.sg721BaseQueryKeys.address(contractAddress)[0]), { method: "collection_info", args })]
};
function useSg721BaseCollectionInfoQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.sg721BaseQueryKeys.collectionInfo(client === null || client === void 0 ? void 0 : client.contractAddress), () => client ? client.collectionInfo() : Promise.reject(new Error("Invalid client")), Object.assign(Object.assign({}, options), { enabled: !!client && ((options === null || options === void 0 ? void 0 : options.enabled) != undefined ? options.enabled : true) }));
}
exports.useSg721BaseCollectionInfoQuery = useSg721BaseCollectionInfoQuery;
function useSg721BaseMinterQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.sg721BaseQueryKeys.minter(client === null || client === void 0 ? void 0 : client.contractAddress), () => client ? client.minter() : Promise.reject(new Error("Invalid client")), Object.assign(Object.assign({}, options), { enabled: !!client && ((options === null || options === void 0 ? void 0 : options.enabled) != undefined ? options.enabled : true) }));
}
exports.useSg721BaseMinterQuery = useSg721BaseMinterQuery;
function useSg721BaseAllTokensQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.sg721BaseQueryKeys.allTokens(client === null || client === void 0 ? void 0 : client.contractAddress, args), () => client ? client.allTokens({
        limit: args.limit,
        startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")), Object.assign(Object.assign({}, options), { enabled: !!client && ((options === null || options === void 0 ? void 0 : options.enabled) != undefined ? options.enabled : true) }));
}
exports.useSg721BaseAllTokensQuery = useSg721BaseAllTokensQuery;
function useSg721BaseTokensQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.sg721BaseQueryKeys.tokens(client === null || client === void 0 ? void 0 : client.contractAddress, args), () => client ? client.tokens({
        limit: args.limit,
        owner: args.owner,
        startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")), Object.assign(Object.assign({}, options), { enabled: !!client && ((options === null || options === void 0 ? void 0 : options.enabled) != undefined ? options.enabled : true) }));
}
exports.useSg721BaseTokensQuery = useSg721BaseTokensQuery;
function useSg721BaseAllNftInfoQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.sg721BaseQueryKeys.allNftInfo(client === null || client === void 0 ? void 0 : client.contractAddress, args), () => client ? client.allNftInfo({
        includeExpired: args.includeExpired,
        tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")), Object.assign(Object.assign({}, options), { enabled: !!client && ((options === null || options === void 0 ? void 0 : options.enabled) != undefined ? options.enabled : true) }));
}
exports.useSg721BaseAllNftInfoQuery = useSg721BaseAllNftInfoQuery;
function useSg721BaseNftInfoQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.sg721BaseQueryKeys.nftInfo(client === null || client === void 0 ? void 0 : client.contractAddress, args), () => client ? client.nftInfo({
        tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")), Object.assign(Object.assign({}, options), { enabled: !!client && ((options === null || options === void 0 ? void 0 : options.enabled) != undefined ? options.enabled : true) }));
}
exports.useSg721BaseNftInfoQuery = useSg721BaseNftInfoQuery;
function useSg721BaseContractInfoQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.sg721BaseQueryKeys.contractInfo(client === null || client === void 0 ? void 0 : client.contractAddress), () => client ? client.contractInfo() : Promise.reject(new Error("Invalid client")), Object.assign(Object.assign({}, options), { enabled: !!client && ((options === null || options === void 0 ? void 0 : options.enabled) != undefined ? options.enabled : true) }));
}
exports.useSg721BaseContractInfoQuery = useSg721BaseContractInfoQuery;
function useSg721BaseNumTokensQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.sg721BaseQueryKeys.numTokens(client === null || client === void 0 ? void 0 : client.contractAddress), () => client ? client.numTokens() : Promise.reject(new Error("Invalid client")), Object.assign(Object.assign({}, options), { enabled: !!client && ((options === null || options === void 0 ? void 0 : options.enabled) != undefined ? options.enabled : true) }));
}
exports.useSg721BaseNumTokensQuery = useSg721BaseNumTokensQuery;
function useSg721BaseAllOperatorsQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.sg721BaseQueryKeys.allOperators(client === null || client === void 0 ? void 0 : client.contractAddress, args), () => client ? client.allOperators({
        includeExpired: args.includeExpired,
        limit: args.limit,
        owner: args.owner,
        startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")), Object.assign(Object.assign({}, options), { enabled: !!client && ((options === null || options === void 0 ? void 0 : options.enabled) != undefined ? options.enabled : true) }));
}
exports.useSg721BaseAllOperatorsQuery = useSg721BaseAllOperatorsQuery;
function useSg721BaseApprovalsQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.sg721BaseQueryKeys.approvals(client === null || client === void 0 ? void 0 : client.contractAddress, args), () => client ? client.approvals({
        includeExpired: args.includeExpired,
        tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")), Object.assign(Object.assign({}, options), { enabled: !!client && ((options === null || options === void 0 ? void 0 : options.enabled) != undefined ? options.enabled : true) }));
}
exports.useSg721BaseApprovalsQuery = useSg721BaseApprovalsQuery;
function useSg721BaseApprovalQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.sg721BaseQueryKeys.approval(client === null || client === void 0 ? void 0 : client.contractAddress, args), () => client ? client.approval({
        includeExpired: args.includeExpired,
        spender: args.spender,
        tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")), Object.assign(Object.assign({}, options), { enabled: !!client && ((options === null || options === void 0 ? void 0 : options.enabled) != undefined ? options.enabled : true) }));
}
exports.useSg721BaseApprovalQuery = useSg721BaseApprovalQuery;
function useSg721BaseOwnerOfQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.sg721BaseQueryKeys.ownerOf(client === null || client === void 0 ? void 0 : client.contractAddress, args), () => client ? client.ownerOf({
        includeExpired: args.includeExpired,
        tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")), Object.assign(Object.assign({}, options), { enabled: !!client && ((options === null || options === void 0 ? void 0 : options.enabled) != undefined ? options.enabled : true) }));
}
exports.useSg721BaseOwnerOfQuery = useSg721BaseOwnerOfQuery;
